import os
import discord
import openai
from dotenv import load_dotenv
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
GUILD_ID = os.getenv('DISCORD_GUILD')
bot = discord.Bot()
openai.api_key = os.getenv('GPT3_TOKEN')
MODEL_NAME = os.getenv('MODEL_NAME')
TEMP = os.getenv('TEMPERATURE')
BEST_OF = os.getenv('BEST_OF')
FREQ_PENALTY = os.getenv('FREQ_PENALTY')
PRES_PENALTY = os.getenv('PRES_PENALTY')
NUM_QUOTES = os.getenv('NUM_QUOTES')
END_PROMPT = os.getenv('END_PROMPT')
MAX_TOKENS = os.getenv('MAX_TOKENS')
WAIT_MSG = 'Thinking...'

@bot.event
async def on_ready():
    print(f'{bot.user} connected successfully')

# Extended message length limit: Generated messages can now be up to 8 times as long.
# Added formatting to /user and /message, to indicate which parts of the response are given by the user versus generated by the bot.
# Added moderation to outputs, to comply with OpenAI's terms of service.
# Added usernames to API calls, meaning we can now track how much each user uses the bot.
# TODO: Optimize GPT-3 params further
# /converse now uses the last 10 human messages, meaning it works regardless of how cluttered the channel is with bot activity.
# TODO: Add a /screenshot command that generates a screenshot
# TODO: Add channels to training data + handle in output
# TODO: Add a regex filter to output that takes <:text:[numbers] and converts to closest emoji.
# TODO: Set better defaults in .env

# Encode unsafe characters in the given string. The reverse parameter instead decodes the string.
def replace_unsafe_chars(input_string, reverse = False):
    replace_map = (
        ("]", '&(rb)'),
        ('[', '&(lb)'),
        (';', '&(sc)'),
        ('\n', '&(nl)'),
        ('|', '&(pi)'),
        ("\"", '&(quot)'),
        ("\\", '&(bksl)'),
        ("	", '&(tab)'),
    )
    if not reverse:
        for mapping in replace_map:
            input_string = input_string.replace(mapping[0], mapping[1])
    else:
        for mapping in replace_map:
            input_string = input_string.replace(mapping[1], mapping[0])
    return input_string

# Formats a string into the discord format
def format_string(input_string):
    replace_map = (
        (": ", ';'),
        ("", ']'),
        ("", '[')
    )
    # For discord, remove the reply section, if it exists.
    # Replies are hard to display in a text-only format. For other versions using the same model, we may still want to keep them.
    input_string = input_string.split('|', 1)[0] + ']'
    for mapping in replace_map:
        input_string = input_string.replace(mapping[1], mapping[0])
    return input_string

# Generate a number of messages based on a prompt
def recursive_generate(prompt, num_quotes, uname='NoName'):
    output = ''
    for i in range(num_quotes):
        response = openai.Completion.create(user=uname, model=MODEL_NAME, temperature=float(TEMP), best_of=int(BEST_OF), n=1, stop='\n', prompt=prompt + END_PROMPT, frequency_penalty=float(FREQ_PENALTY), presence_penalty=float(PRES_PENALTY), max_tokens=int(MAX_TOKENS))
        message_str = ''
        for content in response.choices:
            curr_str = replace_unsafe_chars(format_string(content.text), True)
            # Omit unsafe output, if generated
            if openai.Moderation.create(input=curr_str)['results'][0]['flagged']:
                print('Removed unsafe output: ' + curr_str)
                continue
            message_str += curr_str + '\n'
            prompt += content.text + '\n'
        output += message_str
    return output

@bot.slash_command(description='Generate a short conversation.')
async def au(ctx):
    await ctx.respond(WAIT_MSG)
    output = recursive_generate('[', int(NUM_QUOTES), ctx.author.name)
    return await ctx.edit(content=output)

@bot.slash_command(description='Generate a random quote from a specific user.')
async def user(ctx, user):
    await ctx.respond(WAIT_MSG)
    output = '`' + user + '`: ' + recursive_generate('[' + user + ';', int(NUM_QUOTES), ctx.author.name)
    return await ctx.edit(content=output)

@bot.slash_command(description='Generate a random quote from a specific user.')
async def message(ctx, user, message):
    await ctx.respond(WAIT_MSG)
    output = '`' + user + ': ' + message + '`' + '\n' + recursive_generate('[' + user + ';' + message + ']\n[', int(NUM_QUOTES), ctx.author.name)
    return await ctx.edit(content=output)

@bot.slash_command(description='Continue the conversation.')
async def converse(ctx):
    await ctx.respond(WAIT_MSG)
    prompt = ''
    def predicate(message):
        return not message.author.bot
    '''
    for message in reversed(await ctx.channel.history(limit=10).filter(predicate).flatten()):
        prompt+= '[' + replace_unsafe_chars(message.author.name)
        prompt += ';' + replace_unsafe_chars(message.content) + ']\n'
    '''
    limit = 0
    async for message in ctx.channel.history().filter(predicate):
        if limit >= 10: break
        prompt += '[' + replace_unsafe_chars(message.author.name)
        prompt += ';' + replace_unsafe_chars(message.content) + ']\n'
        limit += 1
    output = recursive_generate(prompt + '[', int(NUM_QUOTES), ctx.author.name)
    return await ctx.edit(content=output)

bot.run(TOKEN)